// Prisma schema file for Midcurve Finance
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Models for concentrated liquidity positions
// Supporting: Uniswap V3 (Ethereum), Orca (Solana), Raydium (Solana), PancakeSwap (BSC)

// =============================================================================
// Strategy Models
// =============================================================================

// Strategy lifecycle states
// - pending: Created in DB, not yet deployed on-chain
// - active: Running on-chain
// - paused: Soft pause (DB-only, for UI/API control)
// - shutdown: Permanently stopped
enum StrategyStatus {
  pending
  active
  paused
  shutdown
}

// Strategy position lifecycle states
// - pending: Created in DB, not yet active
// - active: Position is active
// - paused: Position is temporarily paused
// - closed: Position has been closed
enum StrategyPositionStatus {
  pending
  active
  paused
  closed
}

// StrategyManifest - Deployable strategy contract definition
// Contains ABI, bytecode, and parameter schemas for strategy deployment
model StrategyManifest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Identification
  slug        String @unique // "funding-example-v1", "delta-neutral-v1"
  version     String // "1.0.0"
  name        String // "Funding Example Strategy"
  description String // User-friendly description (supports markdown)

  // Contract Artifacts
  abi      Json // Full ABI array (viem-compatible)
  bytecode String // Compiled bytecode (0x...)

  // Constructor Parameters (JSON array of ConstructorParam objects)
  // Each param: { name, type, source, label?, description?, required?, default?, validation? }
  constructorParams Json

  // Capabilities (JSON object)
  // { funding: bool, ohlcConsumer: bool, poolConsumer: bool, balanceConsumer: bool, uniswapV3Actions: bool }
  capabilities Json

  // Basic Currency - strategy's quote token for metrics
  basicCurrencyId String
  basicCurrency   Token  @relation("ManifestBasicCurrency", fields: [basicCurrencyId], references: [id])

  // User-Configurable Parameters (JSON array of UserParam objects)
  // Stored in strategy.config at deployment
  // Each param: { name, type, label, description, required, default?, options?, validation? }
  userParams Json

  // Status
  isActive  Boolean @default(true) // Available for deployment
  isAudited Boolean @default(false) // Has been audited

  // Metadata
  author     String?
  repository String?
  tags       String[] // ["yield", "funding", "example"]

  // Relations
  strategies Strategy[]

  @@index([isActive])
  @@index([basicCurrencyId])
  @@map("strategy_manifests")
}

// Strategy - Automated trading/liquidity management unit
// Can manage multiple positions across different protocols
model Strategy {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Identification
  name         String // "ETH-USDC Delta Neutral"
  strategyType String // "delta-neutral", "yield-optimizer"
  status       StrategyStatus @default(pending)

  // On-chain identification (nullable until deployed)
  // Contract address is the primary lookup field (strategies always have EVM addresses)
  contractAddress String? @unique
  chainId         Int?

  // Quote token reference (all positions must use same quote token)
  // Required for meaningful metrics aggregation
  // All positions in this strategy must use the same quote token
  quoteTokenId String
  quoteToken   Token  @relation(fields: [quoteTokenId], references: [id])

  // NOTE: Metrics are NOT stored - computed on-demand by StrategyMetricsService
  // from StrategyLedgerEvent aggregations and position state
  // See: StrategyMetrics, StrategyPositionMetrics types in midcurve-shared

  // Free-form config (JSON)
  config Json

  // Manifest used for deployment (nullable for manually created strategies)
  manifestId String?
  manifest   StrategyManifest? @relation(fields: [manifestId], references: [id])

  // Relations
  automationWallets    AutomationWallet[]
  strategyPositions    StrategyPosition[]
  strategyLedgerEvents StrategyLedgerEvent[]

  // Indexes
  @@index([userId])
  @@index([status])
  @@index([strategyType])
  @@index([quoteTokenId])
  @@index([manifestId])
  @@map("strategies")
}

// StrategyPosition - Position owned by a Strategy (not User)
// Supports multiple position types: hodl, uniswapv3, hyperliquid, etc.
model StrategyPosition {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Parent strategy
  strategyId String
  strategy   Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  // Type discriminator
  positionType String // 'hodl', 'uniswapv3', 'hyperliquid'

  // Lifecycle
  status   StrategyPositionStatus @default(pending)
  openedAt DateTime?
  closedAt DateTime?

  // Type-specific data (JSON)
  // Config: Immutable configuration (wallets, addresses, etc.)
  // State: Mutable state (balances, holdings, etc.)
  config Json
  state  Json

  // Relations
  ledgerEvents StrategyLedgerEvent[]

  // Indexes
  @@index([strategyId])
  @@index([positionType])
  @@index([status])
  @@map("strategy_positions")
}

// StrategyLedgerEvent - Financial events for Strategy positions
// Unified event taxonomy for all strategy position types
model StrategyLedgerEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Parent references
  strategyId         String
  strategy           Strategy         @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  strategyPositionId String
  strategyPosition   StrategyPosition @relation(fields: [strategyPositionId], references: [id], onDelete: Cascade)

  // Grouping & Ordering
  // groupId: UUID that groups related events atomically (e.g., SWAP = BUY + SELL + FEE_PAID + GAS_PAID)
  // sequenceNumber: Order within same timestamp (0, 1, 2...) - resets per timestamp
  groupId        String
  timestamp      DateTime
  sequenceNumber Int

  // Event identification
  // Types: INVESTOR_DEPOSIT, INVESTOR_WITHDRAW, BUY, SELL, POSITION_ENTER, POSITION_INCREASE,
  //        POSITION_DECREASE, POSITION_EXIT, FEE_EARNED, YIELD_EARNED, FUNDING_RECEIVED,
  //        FUNDING_PAID, FEE_PAID, GAS_PAID, ALLOCATION_TO_POSITION, ALLOCATION_FROM_POSITION
  eventType String

  // Asset
  tokenId      String
  token        Token  @relation(fields: [tokenId], references: [id])
  tokenHash    String // "erc20:chainId:address" for readability/logging
  amount       String // bigint as string (+ inflow, - outflow)
  valueInQuote String // bigint as string - Value in strategy's quote token

  // Financial tracking (deltas only - aggregate for totals)
  // See StrategyMetrics in midcurve-shared for aggregation semantics
  deltaCostBasis           String @default("0") // bigint as string - Change in cost basis
  deltaRealizedCapitalGain String @default("0") // bigint as string - Capital gain/loss from sales
  deltaRealizedIncome      String @default("0") // bigint as string - Realized income (fees, yield)
  deltaExpense             String @default("0") // bigint as string - Expenses (gas, protocol fees)

  // Protocol-specific data (JSON)
  config Json // Immutable event metadata
  state  Json // Event-specific data

  // Indexes
  @@index([strategyId])
  @@index([strategyPositionId])
  @@index([groupId])
  @@index([timestamp, sequenceNumber])
  @@index([tokenId])
  @@index([eventType])
  @@map("strategy_ledger_events")
}

// =============================================================================
// Authentication Models
// =============================================================================

// AuthAccount - Auth.js adapter model for OAuth/provider accounts
model AuthAccount {
  id                String @id @default(cuid())
  userId            String
  type              String // "credentials" for wallet auth
  provider          String // "siwe" for Ethereum wallets
  providerAccountId String // Wallet address (normalized EIP-55)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints
  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("auth_accounts")
}

// AuthSession - Auth.js adapter model for active user sessions
model AuthSession {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId])
  @@map("auth_sessions")
}

// AuthVerificationToken - Auth.js adapter model for general-purpose tokens
model AuthVerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  // Constraints
  @@unique([identifier, token])
  @@map("auth_verification_tokens")
}

// AuthWalletAddress - User wallet addresses across multiple EVM chains
model AuthWalletAddress {
  id        String   @id @default(cuid())
  userId    String
  address   String // Normalized (EIP-55 checksum)
  chainId   Int // 1 (Ethereum), 42161 (Arbitrum), 8453 (Base), 56 (BSC), 137 (Polygon), 10 (Optimism)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints
  @@unique([address, chainId])
  @@index([userId])
  @@index([address])
  @@map("auth_wallet_addresses")
}

// ApiKey - API keys for programmatic access
model ApiKey {
  id        String    @id @default(cuid())
  userId    String
  name      String // User-friendly name ("Production API", "Dev Testing")
  keyHash   String    @unique // SHA-256 hash of the API key
  keyPrefix String // First 8 chars for display (e.g., "mc_live_")
  lastUsed  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId])
  @@index([keyHash])
  @@map("api_keys")
}

// =============================================================================
// Cache & Core Models
// =============================================================================

model Cache {
  key       String   @id
  value     Json
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for efficient queries
  @@index([expiresAt])
  @@map("cache")
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User identification
  name  String?
  email String? @unique
  image String?

  // Auth.js relations
  authAccounts AuthAccount[]
  authSessions AuthSession[]

  // Midcurve auth relations
  walletAddresses AuthWalletAddress[]
  apiKeys         ApiKey[]

  // Midcurve position relations
  positions             Position[]
  quoteTokenPreferences UserQuoteTokenPreference[]
  strategies            Strategy[]

  // Indexes for efficient queries
  @@index([name])
  @@index([email])
  @@map("users")
}

model Token {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  tokenType String // 'evm-erc20' or 'solana-spl'
  name      String
  symbol    String
  decimals  Int

  // Common optional fields
  logoUrl     String?
  coingeckoId String?
  marketCap   Float? // USD market cap from CoinGecko

  // Platform-specific configuration (JSON)
  // Contains address/mint, chainId/programId, platform identifier, etc.
  config Json

  // Relations
  poolsAsToken0        Pool[]                @relation("PoolToken0")
  poolsAsToken1        Pool[]                @relation("PoolToken1")
  strategies           Strategy[]
  strategyManifests    StrategyManifest[]    @relation("ManifestBasicCurrency")
  strategyLedgerEvents StrategyLedgerEvent[]

  // Indexes for efficient queries
  @@index([tokenType])
  @@index([symbol])
  @@index([coingeckoId])
  @@map("tokens")
}

model Pool {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  protocol String // 'uniswapv3', etc.
  poolType String // 'CL_TICKS'
  token0Id String
  token1Id String
  feeBps   Int // Fee in basis points (3000 = 0.3%)

  // Protocol-specific configuration (JSON) - Immutable
  // Contains pool address, tick spacing, chainId, token addresses, etc.
  config Json

  // Protocol-specific state (JSON) - Mutable
  // Contains current price, liquidity, tick, fee growth, etc.
  // For Uniswap V3: sqrtPriceX96, currentTick, liquidity, feeGrowthGlobal0/1
  state Json

  // Relations to Token model
  // Note: In TypeScript, Pool.token0 and Pool.token1 are full Token objects
  // In database, we use foreign keys for efficient storage and queries
  token0     Token       @relation("PoolToken0", fields: [token0Id], references: [id])
  token1     Token       @relation("PoolToken1", fields: [token1Id], references: [id])
  positions  Position[]
  poolPrices PoolPrice[]

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolType])
  @@index([token0Id])
  @@index([token1Id])
  @@map("pools")
}

model Position {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol     String // 'uniswapv3', etc.
  positionType String // 'CL_TICKS'

  // Data ownership
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Position hash for fast lookups
  // Human-readable composite key: protocol/chainId/nftId (for UniswapV3)
  // Format is protocol-specific, generated by createPositionHash() method
  // Nullable initially for migration, will become required after backfill
  positionHash String? @unique

  // PnL related fields (stored as string for bigint precision)
  currentValue     String // bigint as string
  currentCostBasis String // bigint as string
  realizedPnl      String // bigint as string
  unrealizedPnl    String // bigint as string

  // General cash flow fields for non-AMM protocols (stored as string for bigint precision)
  // For UniswapV3: always "0" (unused - fees tracked in collectedFees/unClaimedFees)
  // For Hyperliquid: funding payments, interest, etc.
  // Total Realized PnL = realizedPnl + realizedCashflow
  // Total Unrealized PnL = unrealizedPnl + unrealizedCashflow
  realizedCashflow   String @default("0") // bigint as string - locked-in cash flow
  unrealizedCashflow String @default("0") // bigint as string - pending cash flow

  // Cash flow related fields for AMM protocols (stored as string for bigint precision)
  collectedFees       String // bigint as string
  unClaimedFees       String // bigint as string
  lastFeesCollectedAt DateTime? // null = no fees collected yet

  // APR metrics
  totalApr Float? // Total APR (time-weighted across all periods + unrealized), null if below threshold

  // Price range (stored as string for bigint precision)
  priceRangeLower String // bigint as string
  priceRangeUpper String // bigint as string

  // Pool and token roles
  poolId        String
  pool          Pool    @relation(fields: [poolId], references: [id])
  isToken0Quote Boolean // true: token0 is quote, token1 is base; false: token0 is base, token1 is quote

  // Position state
  positionOpenedAt DateTime
  positionClosedAt DateTime?
  isActive         Boolean

  // Protocol-specific data (JSON)
  config Json // Immutable: chainId, nftId, poolAddress, ticks, etc.
  state  Json // Mutable: ownerAddress, liquidity, feeGrowth, tokensOwed, etc.

  // Relations
  ledgerEvents PositionLedgerEvent[]
  aprPeriods   PositionAprPeriod[]
  syncState    PositionSyncState? // 1:1 relation, optional for backward compatibility

  // Indexes for efficient queries
  @@index([protocol])
  @@index([positionType])
  @@index([userId])
  @@index([poolId])
  @@index([isActive])
  @@index([userId, positionHash]) // Fast user-specific lookups by hash
  @@map("positions")
}

model PositionSyncState {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference (1:1 relationship)
  positionId String   @unique
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Sync tracking
  lastSyncAt DateTime? // null = never synced yet
  lastSyncBy String? // 'user-refresh', future: 'auto-refresh', 'webhook', etc.

  // Protocol-specific sync state (JSON)
  // For UniswapV3: { lastEventBlock: number, lastFinalizedBlock: number, lastEventId: string?, ... }
  // For other protocols: protocol-specific sync metadata
  state Json

  // Indexes for efficient queries
  @@index([positionId])
  @@index([lastSyncAt])
  @@index([lastSyncBy])
  @@map("position_sync_states")
}

model PoolPrice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol String // 'uniswapv3', etc.

  // Pool reference
  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  // Timestamp when price was recorded
  timestamp DateTime

  // Price fields (stored as string for bigint precision)
  // Price in smallest token units
  token1PricePerToken0 String // bigint as string - How much token1 for 1 token0
  token0PricePerToken1 String // bigint as string - How much token0 for 1 token1

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (e.g., blockNumber, blockTimestamp for Uniswap V3)
  state  Json // Protocol-specific state (e.g., sqrtPriceX96, tick for Uniswap V3)

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolId])
  @@index([timestamp])
  @@index([poolId, timestamp]) // Compound index for time-range queries on specific pool
  @@map("pool_prices")
}

model PositionLedgerEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Protocol and event chaining
  protocol      String // 'uniswapv3', etc.
  previousId    String? // null for first event
  previousEvent PositionLedgerEvent?  @relation("EventChain", fields: [previousId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  nextEvents    PositionLedgerEvent[] @relation("EventChain")

  // Event identification
  timestamp DateTime // Block timestamp (from blockchain)
  eventType String // 'INCREASE_POSITION', 'DECREASE_POSITION', 'COLLECT'
  inputHash String   @unique // MD5(positionId + blockNumber + txIndex + logIndex)

  // Financial data (stored as string for bigint precision)
  poolPrice    String // bigint as string - Quote tokens per 1 Base token (in smallest units)
  token0Amount String // bigint as string - Token0 amount in smallest units
  token1Amount String // bigint as string - Token1 amount in smallest units
  tokenValue   String // bigint as string - Total value in quote token units
  rewards      Json // Array of {tokenId: string, tokenAmount: string, tokenValue: string}

  // PnL tracking (stored as string for bigint precision)
  deltaCostBasis String // bigint as string - Change in cost basis from this event
  costBasisAfter String // bigint as string - Cumulative cost basis after this event
  deltaPnl       String // bigint as string - Change in realized PnL from this event
  pnlAfter       String // bigint as string - Cumulative realized PnL after this event

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (blockNumber, txIndex, logIndex, liquidity, fees, etc.)
  state  Json // Raw event data (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, COLLECT)

  // Indexes for efficient queries
  @@index([positionId, timestamp]) // Time-series queries for position
  @@index([protocol]) // Filter by protocol
  @@index([eventType]) // Filter by event type
  @@index([inputHash]) // Deduplication lookups
  @@index([previousId]) // Event chain traversal
  @@map("position_ledger_events")
}

model PositionAprPeriod {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Period boundaries (events that define this period)
  startEventId String // Event that started this period (INCREASE_POSITION or COLLECT)
  endEventId   String // Event that ended this period (next COLLECT or last event)

  // Time range
  startTimestamp  DateTime // When period started
  endTimestamp    DateTime // When period ended (or last event time)
  durationSeconds Int // endTimestamp - startTimestamp (in seconds)

  // Financial metrics (stored as string for bigint precision)
  costBasis         String // Average cost basis during period (in quote token units)
  collectedFeeValue String // Total fees collected during period (in quote token units)

  // APR calculation
  aprBps Int // Annual Percentage Rate in basis points (e.g., 2500 = 25.00%)

  // For debugging/auditing
  eventCount Int // Number of events included in period calculation

  // Indexes for efficient queries
  @@index([positionId, startTimestamp]) // Time-range queries for position
  @@index([positionId, endTimestamp]) // Time-range queries for position
  @@index([aprBps]) // Sort/filter by APR performance
  @@map("position_apr_periods")
}

model UserQuoteTokenPreference {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User reference
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Protocol (NO chainId - preferences are protocol-wide)
  // User can have one preference set per protocol
  protocol String // 'uniswapv3', 'orca', 'raydium', etc.

  // Ordered list of preferred quote token identifiers (protocol-specific)
  // - EVM protocols: normalized addresses ["0xA0b8...", "0xC02a..."]
  // - Solana protocols: mint addresses ["EPjFWdd...", "So11111..."]
  // First match wins when both tokens in pair are in this list
  preferredQuoteTokens Json

  // Composite unique constraint and indexes
  @@unique([userId, protocol])
  @@index([userId])
  @@index([protocol])
  @@map("user_quote_token_preferences")
}

// =============================================================================
// Automation Wallet Models (for midcurve-signer)
// =============================================================================

// AutomationWallet - Managed wallets for automated DeFi operations
// Supports multiple platforms: EVM, Solana, Hyperliquid, etc.
model AutomationWallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Wallet type discriminator
  walletType String // 'evm', 'solana', 'hyperliquid'

  // Owner reference (for authorization, NOT unique - one user can have many wallets)
  userId String

  // Optional strategy reference (one strategy can have multiple wallets)
  strategyId String?
  strategy   Strategy? @relation(fields: [strategyId], references: [id], onDelete: SetNull)

  // User-friendly label
  label String // "Strategy Automation Wallet", "Hyperliquid Trading Wallet", etc.

  // Wallet hash for fast lookups and uniqueness
  // Human-readable composite key, format is platform-specific:
  // - EVM: "evm/{strategyAddress}" (one wallet per strategy)
  // - Solana: "solana/{programId}/{walletPubkey}"
  // - Hyperliquid: "hyperliquid/{userId}/{vaultAddress}"
  // Generated by createWalletHash() method in each platform service
  walletHash String @unique

  // Platform-specific configuration (JSON)
  // EVM: { strategyAddress, walletAddress, kmsKeyId, keyProvider }
  // Solana: { programId, walletPubkey, ... }
  // Hyperliquid: { apiKey, apiSecret (encrypted), ... }
  config Json

  // Status
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?

  // Relations
  nonces AutomationWalletNonce[]

  // Indexes
  @@index([walletType])
  @@index([userId])
  @@index([strategyId])
  @@index([isActive])
  @@index([userId, walletHash]) // Fast user-specific lookups by hash
  @@map("automation_wallets")
}

// AutomationWalletNonce - Per-network nonce tracking for automation wallets
model AutomationWalletNonce {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Wallet reference
  walletId String
  wallet   AutomationWallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  // Nonce hash for uniqueness (similar to positionHash pattern)
  // Format: "{walletId}/{walletType}/{networkIdentifier}"
  // - EVM: "{walletId}/evm/{chainId}"
  // - Solana: "{walletId}/solana/{cluster}"
  // - Hyperliquid: "{walletId}/hyperliquid/mainnet"
  nonceHash String @unique

  // Platform-specific immutable config (JSON)
  // EVM: { chainId: number }
  // Solana: { cluster: 'mainnet-beta' | 'devnet' }
  // Hyperliquid: { network: 'mainnet' }
  config Json

  // Mutable state (JSON)
  // All platforms: { nonce: number }
  state Json

  // Indexes
  @@index([walletId])
  @@map("automation_wallet_nonces")
}
