// Prisma schema file for Midcurve Finance
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Models for concentrated liquidity positions
// Supporting: Uniswap V3 (Ethereum), Orca (Solana), Raydium (Solana), PancakeSwap (BSC)

// =============================================================================
// Strategy Models
// =============================================================================

// Strategy lifecycle states (aligned with on-chain LifecycleMixin)
// - pending: Created in DB, not yet deployed on-chain
// - deploying: Deployment in progress (contract being deployed)
// - deployed: Contract deployed, not started (on-chain: DEPLOYED)
// - starting: START event sent, processing (on-chain: STARTING)
// - active: Fully running (on-chain: ACTIVE)
// - shutting_down: SHUTDOWN event sent, cleanup in progress (on-chain: SHUTTING_DOWN)
// - shutdown: Final state (on-chain: SHUTDOWN)
enum StrategyStatus {
  pending
  deploying
  deployed
  starting
  active
  shutting_down
  shutdown
}

// Strategy position lifecycle states
// - pending: Created in DB, not yet active
// - active: Position is active
// - paused: Position is temporarily paused
// - closed: Position has been closed
enum StrategyPositionStatus {
  pending
  active
  paused
  closed
}

// Strategy - Automated trading/liquidity management unit
// Can manage multiple positions across different protocols
model Strategy {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Identification
  name         String // "ETH-USDC Delta Neutral"
  strategyType String // "delta-neutral", "yield-optimizer"
  status       StrategyStatus @default(pending)

  // On-chain identification (nullable until deployed)
  // Contract address is the primary lookup field (strategies always have EVM addresses)
  contractAddress String? @unique
  chainId         Int?

  // Quote token reference (all positions must use same quote token)
  // Required for meaningful metrics aggregation
  // All positions in this strategy must use the same quote token
  quoteTokenId String
  quoteToken   Token  @relation(fields: [quoteTokenId], references: [id])

  // NOTE: Metrics are NOT stored - computed on-demand by StrategyMetricsService
  // from StrategyLedgerEvent aggregations and position state
  // See: StrategyMetrics, StrategyPositionMetrics types in midcurve-shared

  // Free-form config (JSON)
  config Json

  // Embedded manifest used for deployment (nullable for manually created strategies)
  // Contains: name, version, description, author, abi, bytecode, constructorParams, tags
  // See StrategyManifest type in @midcurve/shared for structure
  manifest Json?

  // Vault deployment info (nullable until vault deployed)
  // Platform-independent config stored as JSON: { type: 'evm', chainId: number, vaultAddress: string }
  // See VaultConfig type in midcurve-evm for structure
  vaultConfig     Json?
  vaultTokenId    String? // Reference to Token record for funding token (separate for easy lookup)
  vaultDeployedAt DateTime?

  // Vault token relation
  vaultToken Token? @relation("StrategyVaultToken", fields: [vaultTokenId], references: [id])

  // Relations
  automationWallets    AutomationWallet[]
  strategyPositions    StrategyPosition[]
  strategyLedgerEvents StrategyLedgerEvent[]
  logs                 StrategyLog[]

  // Indexes
  @@index([userId])
  @@index([status])
  @@index([strategyType])
  @@index([quoteTokenId])
  @@index([vaultTokenId])
  @@map("strategies")
}

// StrategyPosition - Position owned by a Strategy (not User)
// Supports multiple position types: treasury, uniswapv3, hyperliquid, etc.
model StrategyPosition {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Parent strategy
  strategyId String
  strategy   Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  // Type discriminator
  positionType String // 'treasury', 'uniswapv3', 'hyperliquid'

  // Lifecycle
  status   StrategyPositionStatus @default(pending)
  openedAt DateTime?
  closedAt DateTime?

  // Type-specific data (JSON)
  // Config: Immutable configuration (wallets, addresses, etc.)
  // State: Mutable state (balances, holdings, etc.)
  config Json
  state  Json

  // Relations
  ledgerEvents StrategyLedgerEvent[]

  // Indexes
  @@index([strategyId])
  @@index([positionType])
  @@index([status])
  @@map("strategy_positions")
}

// StrategyLedgerEvent - Financial events for Strategy positions
// Unified event taxonomy for all strategy position types
model StrategyLedgerEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Parent references
  strategyId         String
  strategy           Strategy         @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  strategyPositionId String
  strategyPosition   StrategyPosition @relation(fields: [strategyPositionId], references: [id], onDelete: Cascade)

  // Grouping & Ordering
  // groupId: UUID that groups related events atomically (e.g., SWAP = BUY + SELL + FEE_PAID + GAS_PAID)
  // sequenceNumber: Order within same timestamp (0, 1, 2...) - resets per timestamp
  groupId        String
  timestamp      DateTime
  sequenceNumber Int

  // Event identification
  // Types: INVESTOR_DEPOSIT, INVESTOR_WITHDRAW, BUY, SELL, POSITION_ENTER, POSITION_INCREASE,
  //        POSITION_DECREASE, POSITION_EXIT, FEE_EARNED, YIELD_EARNED, FUNDING_RECEIVED,
  //        FUNDING_PAID, FEE_PAID, GAS_PAID, ALLOCATION_TO_POSITION, ALLOCATION_FROM_POSITION
  eventType String

  // Asset
  tokenId      String
  token        Token  @relation(fields: [tokenId], references: [id])
  tokenHash    String // "erc20:chainId:address" for readability/logging
  amount       String // bigint as string (+ inflow, - outflow)
  valueInQuote String // bigint as string - Value in strategy's quote token

  // Financial tracking (deltas only - aggregate for totals)
  // See StrategyMetrics in midcurve-shared for aggregation semantics
  deltaCostBasis           String @default("0") // bigint as string - Change in cost basis
  deltaRealizedCapitalGain String @default("0") // bigint as string - Capital gain/loss from sales
  deltaRealizedIncome      String @default("0") // bigint as string - Realized income (fees, yield)
  deltaExpense             String @default("0") // bigint as string - Expenses (gas, protocol fees)

  // Protocol-specific data (JSON)
  config Json // Immutable event metadata
  state  Json // Event-specific data

  // Indexes
  @@index([strategyId])
  @@index([strategyPositionId])
  @@index([groupId])
  @@index([timestamp, sequenceNumber])
  @@index([tokenId])
  @@index([eventType])
  @@map("strategy_ledger_events")
}

// StrategyLog - Durable log messages from strategy execution
// Logs are emitted via LoggingMixin and persisted by the LogEffectHandler
model StrategyLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Strategy reference
  strategyId String
  strategy   Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  // Denormalized for display (avoids join for simple log viewing)
  contractAddress String // 0x... checksummed address

  // Execution context
  epoch         BigInt // Strategy epoch when log was emitted
  correlationId String // Distributed tracing ID

  // Log content
  level       Int // 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR
  topic       String // bytes32 hash (hex string)
  topicName   String? // Human-readable topic name (if known)
  data        String // bytes hex string (raw encoded data)
  dataDecoded String? // Human-readable decoded data (if possible)

  // Timing
  timestamp DateTime // When the log was created (from requestedAt)

  // Indexes for efficient querying
  @@index([strategyId, timestamp])
  @@index([strategyId, level, timestamp])
  @@index([timestamp])
  @@map("strategy_logs")
}

// =============================================================================
// Authentication Models
// =============================================================================

// Session - Custom server-side session storage (replaces Auth.js JWT)
// Session ID stored in httpOnly cookie, session data stored in PostgreSQL
model Session {
  id        String @id @default(cuid())
  sessionId String @unique // 64-char random token stored in httpOnly cookie
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session metadata
  createdAt  DateTime @default(now())
  expiresAt  DateTime // Session expiry time (default 30 days)
  lastUsedAt DateTime @default(now())

  // Security context
  userAgent String? // Browser user agent for session tracking
  ipAddress String? // IP address for session tracking

  @@index([sessionId])
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

// AuthWalletAddress - User wallet addresses across multiple EVM chains
model AuthWalletAddress {
  id        String   @id @default(cuid())
  userId    String
  address   String // Normalized (EIP-55 checksum)
  chainId   Int // 1 (Ethereum), 42161 (Arbitrum), 8453 (Base), 56 (BSC), 137 (Polygon), 10 (Optimism)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints
  @@unique([address, chainId])
  @@index([userId])
  @@index([address])
  @@map("auth_wallet_addresses")
}

// =============================================================================
// Cache & Core Models
// =============================================================================

model Cache {
  key       String   @id
  value     Json
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for efficient queries
  @@index([expiresAt])
  @@map("cache")
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User identification
  name  String?
  email String? @unique
  image String?

  // Session relation (custom server-side sessions)
  sessions Session[]

  // Wallet addresses
  walletAddresses AuthWalletAddress[]

  // Midcurve position relations
  positions             Position[]
  quoteTokenPreferences UserQuoteTokenPreference[]
  strategies            Strategy[]

  // Indexes for efficient queries
  @@index([name])
  @@index([email])
  @@map("users")
}

model Token {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  tokenType String // 'evm-erc20' or 'solana-spl'
  name      String
  symbol    String
  decimals  Int

  // Common optional fields
  logoUrl     String?
  coingeckoId String?
  marketCap   Float? // USD market cap from CoinGecko

  // Platform-specific configuration (JSON)
  // Contains address/mint, chainId/programId, platform identifier, etc.
  config Json

  // Relations
  poolsAsToken0          Pool[]                @relation("PoolToken0")
  poolsAsToken1          Pool[]                @relation("PoolToken1")
  strategies             Strategy[]
  strategiesAsVaultToken Strategy[]            @relation("StrategyVaultToken")
  strategyLedgerEvents   StrategyLedgerEvent[]

  // Indexes for efficient queries
  @@index([tokenType])
  @@index([symbol])
  @@index([coingeckoId])
  @@map("tokens")
}

model Pool {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  protocol String // 'uniswapv3', etc.
  poolType String // 'CL_TICKS'
  token0Id String
  token1Id String
  feeBps   Int // Fee in basis points (3000 = 0.3%)

  // Protocol-specific configuration (JSON) - Immutable
  // Contains pool address, tick spacing, chainId, token addresses, etc.
  config Json

  // Protocol-specific state (JSON) - Mutable
  // Contains current price, liquidity, tick, fee growth, etc.
  // For Uniswap V3: sqrtPriceX96, currentTick, liquidity, feeGrowthGlobal0/1
  state Json

  // Relations to Token model
  // Note: In TypeScript, Pool.token0 and Pool.token1 are full Token objects
  // In database, we use foreign keys for efficient storage and queries
  token0     Token       @relation("PoolToken0", fields: [token0Id], references: [id])
  token1     Token       @relation("PoolToken1", fields: [token1Id], references: [id])
  positions  Position[]
  poolPrices PoolPrice[]

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolType])
  @@index([token0Id])
  @@index([token1Id])
  @@map("pools")
}

model Position {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol     String // 'uniswapv3', etc.
  positionType String // 'CL_TICKS'

  // Data ownership
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Position hash for fast lookups
  // Human-readable composite key: protocol/chainId/nftId (for UniswapV3)
  // Format is protocol-specific, generated by createPositionHash() method
  // Nullable initially for migration, will become required after backfill
  positionHash String? @unique

  // PnL related fields (stored as string for bigint precision)
  currentValue     String // bigint as string
  currentCostBasis String // bigint as string
  realizedPnl      String // bigint as string
  unrealizedPnl    String // bigint as string

  // General cash flow fields for non-AMM protocols (stored as string for bigint precision)
  // For UniswapV3: always "0" (unused - fees tracked in collectedFees/unClaimedFees)
  // For Hyperliquid: funding payments, interest, etc.
  // Total Realized PnL = realizedPnl + realizedCashflow
  // Total Unrealized PnL = unrealizedPnl + unrealizedCashflow
  realizedCashflow   String @default("0") // bigint as string - locked-in cash flow
  unrealizedCashflow String @default("0") // bigint as string - pending cash flow

  // Cash flow related fields for AMM protocols (stored as string for bigint precision)
  collectedFees       String // bigint as string
  unClaimedFees       String // bigint as string
  lastFeesCollectedAt DateTime? // null = no fees collected yet

  // APR metrics
  totalApr Float? // Total APR (time-weighted across all periods + unrealized), null if below threshold

  // Price range (stored as string for bigint precision)
  priceRangeLower String // bigint as string
  priceRangeUpper String // bigint as string

  // Pool and token roles
  poolId        String
  pool          Pool    @relation(fields: [poolId], references: [id])
  isToken0Quote Boolean // true: token0 is quote, token1 is base; false: token0 is base, token1 is quote

  // Position state
  positionOpenedAt DateTime
  positionClosedAt DateTime?
  isActive         Boolean

  // Protocol-specific data (JSON)
  config Json // Immutable: chainId, nftId, poolAddress, ticks, etc.
  state  Json // Mutable: ownerAddress, liquidity, feeGrowth, tokensOwed, etc.

  // Relations
  ledgerEvents PositionLedgerEvent[]
  aprPeriods   PositionAprPeriod[]
  syncState    PositionSyncState? // 1:1 relation, optional for backward compatibility

  // Indexes for efficient queries
  @@index([protocol])
  @@index([positionType])
  @@index([userId])
  @@index([poolId])
  @@index([isActive])
  @@index([userId, positionHash]) // Fast user-specific lookups by hash
  @@map("positions")
}

model PositionSyncState {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference (1:1 relationship)
  positionId String   @unique
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Sync tracking
  lastSyncAt DateTime? // null = never synced yet
  lastSyncBy String? // 'user-refresh', future: 'auto-refresh', 'webhook', etc.

  // Protocol-specific sync state (JSON)
  // For UniswapV3: { lastEventBlock: number, lastFinalizedBlock: number, lastEventId: string?, ... }
  // For other protocols: protocol-specific sync metadata
  state Json

  // Indexes for efficient queries
  @@index([positionId])
  @@index([lastSyncAt])
  @@index([lastSyncBy])
  @@map("position_sync_states")
}

model PoolPrice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol String // 'uniswapv3', etc.

  // Pool reference
  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  // Timestamp when price was recorded
  timestamp DateTime

  // Price fields (stored as string for bigint precision)
  // Price in smallest token units
  token1PricePerToken0 String // bigint as string - How much token1 for 1 token0
  token0PricePerToken1 String // bigint as string - How much token0 for 1 token1

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (e.g., blockNumber, blockTimestamp for Uniswap V3)
  state  Json // Protocol-specific state (e.g., sqrtPriceX96, tick for Uniswap V3)

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolId])
  @@index([timestamp])
  @@index([poolId, timestamp]) // Compound index for time-range queries on specific pool
  @@map("pool_prices")
}

model PositionLedgerEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Protocol and event chaining
  protocol      String // 'uniswapv3', etc.
  previousId    String? // null for first event
  previousEvent PositionLedgerEvent?  @relation("EventChain", fields: [previousId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  nextEvents    PositionLedgerEvent[] @relation("EventChain")

  // Event identification
  timestamp DateTime // Block timestamp (from blockchain)
  eventType String // 'INCREASE_POSITION', 'DECREASE_POSITION', 'COLLECT'
  inputHash String   @unique // MD5(positionId + blockNumber + txIndex + logIndex)

  // Financial data (stored as string for bigint precision)
  poolPrice    String // bigint as string - Quote tokens per 1 Base token (in smallest units)
  token0Amount String // bigint as string - Token0 amount in smallest units
  token1Amount String // bigint as string - Token1 amount in smallest units
  tokenValue   String // bigint as string - Total value in quote token units
  rewards      Json // Array of {tokenId: string, tokenAmount: string, tokenValue: string}

  // PnL tracking (stored as string for bigint precision)
  deltaCostBasis String // bigint as string - Change in cost basis from this event
  costBasisAfter String // bigint as string - Cumulative cost basis after this event
  deltaPnl       String // bigint as string - Change in realized PnL from this event
  pnlAfter       String // bigint as string - Cumulative realized PnL after this event

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (blockNumber, txIndex, logIndex, liquidity, fees, etc.)
  state  Json // Raw event data (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, COLLECT)

  // Indexes for efficient queries
  @@index([positionId, timestamp]) // Time-series queries for position
  @@index([protocol]) // Filter by protocol
  @@index([eventType]) // Filter by event type
  @@index([inputHash]) // Deduplication lookups
  @@index([previousId]) // Event chain traversal
  @@map("position_ledger_events")
}

model PositionAprPeriod {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Period boundaries (events that define this period)
  startEventId String // Event that started this period (INCREASE_POSITION or COLLECT)
  endEventId   String // Event that ended this period (next COLLECT or last event)

  // Time range
  startTimestamp  DateTime // When period started
  endTimestamp    DateTime // When period ended (or last event time)
  durationSeconds Int // endTimestamp - startTimestamp (in seconds)

  // Financial metrics (stored as string for bigint precision)
  costBasis         String // Average cost basis during period (in quote token units)
  collectedFeeValue String // Total fees collected during period (in quote token units)

  // APR calculation
  aprBps Int // Annual Percentage Rate in basis points (e.g., 2500 = 25.00%)

  // For debugging/auditing
  eventCount Int // Number of events included in period calculation

  // Indexes for efficient queries
  @@index([positionId, startTimestamp]) // Time-range queries for position
  @@index([positionId, endTimestamp]) // Time-range queries for position
  @@index([aprBps]) // Sort/filter by APR performance
  @@map("position_apr_periods")
}

model UserQuoteTokenPreference {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User reference
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Protocol (NO chainId - preferences are protocol-wide)
  // User can have one preference set per protocol
  protocol String // 'uniswapv3', 'orca', 'raydium', etc.

  // Ordered list of preferred quote token identifiers (protocol-specific)
  // - EVM protocols: normalized addresses ["0xA0b8...", "0xC02a..."]
  // - Solana protocols: mint addresses ["EPjFWdd...", "So11111..."]
  // First match wins when both tokens in pair are in this list
  preferredQuoteTokens Json

  // Composite unique constraint and indexes
  @@unique([userId, protocol])
  @@index([userId])
  @@index([protocol])
  @@map("user_quote_token_preferences")
}

// =============================================================================
// Automation Wallet Models (for midcurve-signer)
// =============================================================================

// AutomationWallet - Managed wallets for automated DeFi operations
// Supports multiple platforms: EVM, Solana, Hyperliquid, etc.
model AutomationWallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Wallet type discriminator
  walletType String // 'evm', 'solana', 'hyperliquid'

  // Owner reference (for authorization, NOT unique - one user can have many wallets)
  userId String

  // Optional strategy reference (one strategy can have multiple wallets)
  strategyId String?
  strategy   Strategy? @relation(fields: [strategyId], references: [id], onDelete: SetNull)

  // User-friendly label
  label String // "Strategy Automation Wallet", "Hyperliquid Trading Wallet", etc.

  // Wallet hash for fast lookups and uniqueness
  // Human-readable composite key, format is platform-specific:
  // - EVM: "evm/{strategyAddress}" (one wallet per strategy)
  // - Solana: "solana/{programId}/{walletPubkey}"
  // - Hyperliquid: "hyperliquid/{userId}/{vaultAddress}"
  // Generated by createWalletHash() method in each platform service
  walletHash String @unique

  // Platform-specific configuration (JSON)
  // EVM: { strategyAddress, walletAddress, kmsKeyId, keyProvider }
  // Solana: { programId, walletPubkey, ... }
  // Hyperliquid: { apiKey, apiSecret (encrypted), ... }
  config Json

  // Status
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?

  // Relations
  nonces AutomationWalletNonce[]

  // Indexes
  @@index([walletType])
  @@index([userId])
  @@index([strategyId])
  @@index([isActive])
  @@index([userId, walletHash]) // Fast user-specific lookups by hash
  @@map("automation_wallets")
}

// AutomationWalletNonce - Per-network nonce tracking for automation wallets
model AutomationWalletNonce {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Wallet reference
  walletId String
  wallet   AutomationWallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  // Nonce hash for uniqueness (similar to positionHash pattern)
  // Format: "{walletId}/{walletType}/{networkIdentifier}"
  // - EVM: "{walletId}/evm/{chainId}"
  // - Solana: "{walletId}/solana/{cluster}"
  // - Hyperliquid: "{walletId}/hyperliquid/mainnet"
  nonceHash String @unique

  // Platform-specific immutable config (JSON)
  // EVM: { chainId: number }
  // Solana: { cluster: 'mainnet-beta' | 'devnet' }
  // Hyperliquid: { network: 'mainnet' }
  config Json

  // Mutable state (JSON)
  // All platforms: { nonce: number }
  state Json

  // Indexes
  @@index([walletId])
  @@map("automation_wallet_nonces")
}
