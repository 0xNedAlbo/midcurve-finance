// Prisma schema file for Midcurve Finance
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Models for concentrated liquidity positions
// Supporting: Uniswap V3 (Ethereum), Orca (Solana), Raydium (Solana), PancakeSwap (BSC)

// =============================================================================
// Authentication Models
// =============================================================================

// Session - Custom server-side session storage (replaces Auth.js JWT)
// Session ID stored in httpOnly cookie, session data stored in PostgreSQL
model Session {
  id        String @id @default(cuid())
  sessionId String @unique // 64-char random token stored in httpOnly cookie
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session metadata
  createdAt  DateTime @default(now())
  expiresAt  DateTime // Session expiry time (default 30 days)
  lastUsedAt DateTime @default(now())

  // Security context
  userAgent String? // Browser user agent for session tracking
  ipAddress String? // IP address for session tracking

  @@index([sessionId])
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

// AuthWalletAddress - User wallet addresses across multiple EVM chains
model AuthWalletAddress {
  id        String   @id @default(cuid())
  userId    String
  address   String // Normalized (EIP-55 checksum)
  chainId   Int // 1 (Ethereum), 42161 (Arbitrum), 8453 (Base), 56 (BSC), 137 (Polygon), 10 (Optimism)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints
  @@unique([address, chainId])
  @@index([userId])
  @@index([address])
  @@map("auth_wallet_addresses")
}

// =============================================================================
// Cache & Core Models
// =============================================================================

model Cache {
  key       String   @id
  value     Json
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for efficient queries
  @@index([expiresAt])
  @@map("cache")
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User identification
  name  String?
  email String? @unique
  image String?

  // Session relation (custom server-side sessions)
  sessions Session[]

  // Wallet addresses
  walletAddresses AuthWalletAddress[]

  // Midcurve position relations
  positions             Position[]
  quoteTokenPreferences UserQuoteTokenPreference[]

  // Notification relations
  notifications UserNotification[]
  webhookConfig UserWebhookConfig?

  // Indexes for efficient queries
  @@index([name])
  @@index([email])
  @@map("users")
}

model Token {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  tokenType String // 'evm-erc20' or 'solana-spl'
  name      String
  symbol    String
  decimals  Int

  // Common optional fields
  logoUrl     String?
  coingeckoId String?
  marketCap   Float? // USD market cap from CoinGecko

  // Platform-specific configuration (JSON)
  // Contains address/mint, chainId/programId, platform identifier, etc.
  config Json

  // Relations
  poolsAsToken0 Pool[] @relation("PoolToken0")
  poolsAsToken1 Pool[] @relation("PoolToken1")

  // Indexes for efficient queries
  @@index([tokenType])
  @@index([symbol])
  @@index([coingeckoId])
  @@map("tokens")
}

model Pool {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  protocol String // 'uniswapv3', etc.
  poolType String // 'CL_TICKS'
  token0Id String
  token1Id String
  feeBps   Int // Fee in basis points (3000 = 0.3%)

  // Pool hash for fast lookups and uniqueness
  // Human-readable composite key, format: "{protocol}/{chainId}/{poolAddress}"
  // Example: "uniswapv3/1/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8"
  poolHash String? @unique

  // Protocol-specific configuration (JSON) - Immutable
  // Contains pool address, tick spacing, chainId, token addresses, etc.
  config Json

  // Protocol-specific state (JSON) - Mutable
  // Contains current price, liquidity, tick, fee growth, etc.
  // For Uniswap V3: sqrtPriceX96, currentTick, liquidity, feeGrowthGlobal0/1
  state Json

  // Relations to Token model
  // Note: In TypeScript, Pool.token0 and Pool.token1 are full Token objects
  // In database, we use foreign keys for efficient storage and queries
  token0            Token                  @relation("PoolToken0", fields: [token0Id], references: [id])
  token1            Token                  @relation("PoolToken1", fields: [token1Id], references: [id])
  positions         Position[]
  poolPrices        PoolPrice[]
  priceSubscription PoolPriceSubscription? // 1:1 relation for automation price monitoring
  priceSubscribers  PoolPriceSubscribers[] @relation("PoolPriceSubscribers") // 1:N relation for WebSocket price subscriptions
  pricesUniswapV3   PoolPricesUniswapV3[]  @relation("PoolPricesUniswapV3") // Historical prices from Swap events

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolType])
  @@index([token0Id])
  @@index([token1Id])
  @@index([poolHash])
  @@map("pools")
}

model Position {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol     String // 'uniswapv3', etc.
  positionType String // 'CL_TICKS'

  // Data ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Position hash for fast lookups
  // Human-readable composite key: protocol/chainId/nftId (for UniswapV3)
  // Format is protocol-specific, generated by createHash() method
  // Nullable initially for migration, will become required after backfill
  // NOTE: Uniqueness is enforced per-user via @@unique([userId, positionHash])
  // This allows multiple users to import/watch the same on-chain position
  positionHash String?

  // PnL related fields (stored as string for bigint precision)
  currentValue     String // bigint as string
  currentCostBasis String // bigint as string
  realizedPnl      String // bigint as string
  unrealizedPnl    String // bigint as string

  // General cash flow fields for non-AMM protocols (stored as string for bigint precision)
  // For UniswapV3: always "0" (unused - fees tracked in collectedFees/unClaimedFees)
  // For Hyperliquid: funding payments, interest, etc.
  // Total Realized PnL = realizedPnl + realizedCashflow
  // Total Unrealized PnL = unrealizedPnl + unrealizedCashflow
  realizedCashflow   String @default("0") // bigint as string - locked-in cash flow
  unrealizedCashflow String @default("0") // bigint as string - pending cash flow

  // Cash flow related fields for AMM protocols (stored as string for bigint precision)
  collectedFees       String // bigint as string
  unClaimedFees       String // bigint as string
  lastFeesCollectedAt DateTime? // null = no fees collected yet

  // APR metrics
  totalApr Float? // Total APR (time-weighted across all periods + unrealized), null if below threshold

  // Price range (stored as string for bigint precision)
  priceRangeLower String // bigint as string
  priceRangeUpper String // bigint as string

  // Pool and token roles
  poolId        String
  pool          Pool    @relation(fields: [poolId], references: [id])
  isToken0Quote Boolean // true: token0 is quote, token1 is base; false: token0 is base, token1 is quote

  // Position state
  positionOpenedAt DateTime
  positionClosedAt DateTime?
  isActive         Boolean

  // Protocol-specific data (JSON)
  config Json // Immutable: chainId, nftId, poolAddress, ticks, etc.
  state  Json // Mutable: ownerAddress, liquidity, feeGrowth, tokensOwed, etc.

  // Relations
  ledgerEvents     PositionLedgerEvent[]
  aprPeriods       PositionAprPeriod[]
  syncState        PositionSyncState? // 1:1 relation, optional for backward compatibility
  automationOrders AutomationCloseOrder[] // Close orders linked to this position
  automationLogs   AutomationLog[] // Automation event logs for this position
  hedgeVaults      HedgeVault[] // Hedge vaults linked to this position
  notifications    UserNotification[] // Notifications related to this position
  rangeStatus      PositionRangeStatus? // 1:1 range tracking for notifications

  @@unique([userId, positionHash]) // Same user can't import same position twice; allows multi-user watching
  // Indexes for efficient queries
  @@index([protocol])
  @@index([positionType])
  @@index([userId])
  @@index([poolId])
  @@index([isActive])
  @@map("positions")
}

model PositionSyncState {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference (1:1 relationship)
  positionId String   @unique
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Sync tracking
  lastSyncAt DateTime? // null = never synced yet
  lastSyncBy String? // 'user-refresh', future: 'auto-refresh', 'webhook', etc.

  // Protocol-specific sync state (JSON)
  // For UniswapV3: { lastEventBlock: number, lastFinalizedBlock: number, lastEventId: string?, ... }
  // For other protocols: protocol-specific sync metadata
  state Json

  // Indexes for efficient queries
  @@index([positionId])
  @@index([lastSyncAt])
  @@index([lastSyncBy])
  @@map("position_sync_states")
}

model PoolPrice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol String // 'uniswapv3', etc.

  // Pool reference
  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id], onDelete: Cascade)

  // Timestamp when price was recorded
  timestamp DateTime

  // Price fields (stored as string for bigint precision)
  // Price in smallest token units
  token1PricePerToken0 String // bigint as string - How much token1 for 1 token0
  token0PricePerToken1 String // bigint as string - How much token0 for 1 token1

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (e.g., blockNumber, blockTimestamp for Uniswap V3)
  state  Json // Protocol-specific state (e.g., sqrtPriceX96, tick for Uniswap V3)

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolId])
  @@index([timestamp])
  @@index([poolId, timestamp]) // Compound index for time-range queries on specific pool
  @@map("pool_prices")
}

model PositionLedgerEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Protocol and event chaining
  protocol      String // 'uniswapv3', etc.
  previousId    String? // null for first event
  previousEvent PositionLedgerEvent?  @relation("EventChain", fields: [previousId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  nextEvents    PositionLedgerEvent[] @relation("EventChain")

  // Event identification
  timestamp DateTime // Block timestamp (from blockchain)
  eventType String // 'INCREASE_POSITION', 'DECREASE_POSITION', 'COLLECT'
  // inputHash: MD5(blockNumber + txIndex + logIndex) for deduplication within a position
  // NOTE: Uniqueness is enforced per-position via @@unique([positionId, inputHash])
  // This allows multiple users to import the same on-chain position with the same events
  inputHash String

  // Financial data (stored as string for bigint precision)
  poolPrice    String // bigint as string - Quote tokens per 1 Base token (in smallest units)
  token0Amount String // bigint as string - Token0 amount in smallest units
  token1Amount String // bigint as string - Token1 amount in smallest units
  tokenValue   String // bigint as string - Total value in quote token units
  rewards      Json // Array of {tokenId: string, tokenAmount: string, tokenValue: string}

  // PnL tracking (stored as string for bigint precision)
  deltaCostBasis String // bigint as string - Change in cost basis from this event
  costBasisAfter String // bigint as string - Cumulative cost basis after this event
  deltaPnl       String // bigint as string - Change in realized PnL from this event
  pnlAfter       String // bigint as string - Cumulative realized PnL after this event

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (blockNumber, txIndex, logIndex, liquidity, fees, etc.)
  state  Json // Raw event data (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, COLLECT)

  @@unique([positionId, inputHash]) // Deduplication per-position; allows multi-user event import
  // Indexes for efficient queries
  @@index([positionId, timestamp]) // Time-series queries for position
  @@index([protocol]) // Filter by protocol
  @@index([eventType]) // Filter by event type
  @@index([previousId]) // Event chain traversal
  @@map("position_ledger_events")
}

model PositionAprPeriod {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Period boundaries (events that define this period)
  startEventId String // Event that started this period (INCREASE_POSITION or COLLECT)
  endEventId   String // Event that ended this period (next COLLECT or last event)

  // Time range
  startTimestamp  DateTime // When period started
  endTimestamp    DateTime // When period ended (or last event time)
  durationSeconds Int // endTimestamp - startTimestamp (in seconds)

  // Financial metrics (stored as string for bigint precision)
  costBasis         String // Average cost basis during period (in quote token units)
  collectedFeeValue String // Total fees collected during period (in quote token units)

  // APR calculation
  aprBps Int // Annual Percentage Rate in basis points (e.g., 2500 = 25.00%)

  // For debugging/auditing
  eventCount Int // Number of events included in period calculation

  // Indexes for efficient queries
  @@index([positionId, startTimestamp]) // Time-range queries for position
  @@index([positionId, endTimestamp]) // Time-range queries for position
  @@index([aprBps]) // Sort/filter by APR performance
  @@map("position_apr_periods")
}

model UserQuoteTokenPreference {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User reference
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Protocol (NO chainId - preferences are protocol-wide)
  // User can have one preference set per protocol
  protocol String // 'uniswapv3', 'orca', 'raydium', etc.

  // Ordered list of preferred quote token identifiers (protocol-specific)
  // - EVM protocols: normalized addresses ["0xA0b8...", "0xC02a..."]
  // - Solana protocols: mint addresses ["EPjFWdd...", "So11111..."]
  // First match wins when both tokens in pair are in this list
  preferredQuoteTokens Json

  // Composite unique constraint and indexes
  @@unique([userId, protocol])
  @@index([userId])
  @@index([protocol])
  @@map("user_quote_token_preferences")
}

// =============================================================================
// Automation Wallet Models (for midcurve-signer)
// =============================================================================

// AutomationWallet - Managed wallets for automated DeFi operations
// Supports multiple platforms: EVM, Solana, Hyperliquid, etc.
model AutomationWallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Wallet type discriminator
  walletType String // 'evm', 'solana', 'hyperliquid'

  // Wallet purpose discriminator
  walletPurpose String @default("automation") // 'automation'

  // Owner reference (for authorization, NOT unique - one user can have many wallets)
  userId String

  // User-friendly label
  label String // "Automation Wallet", "Hyperliquid Trading Wallet", etc.

  // Wallet hash for fast lookups and uniqueness
  // Human-readable composite key, format is platform-specific:
  // - EVM: "evm/{walletAddress}" (the actual signing wallet address)
  // - Solana: "solana/{programId}/{walletPubkey}"
  // - Hyperliquid: "hyperliquid/{userId}/{vaultAddress}"
  // Generated by createWalletHash() method in each platform service
  walletHash String @unique

  // Platform-specific configuration (JSON)
  // EVM: { walletAddress, kmsKeyId, keyProvider }
  // Solana: { programId, walletPubkey, ... }
  // Hyperliquid: { apiKey, apiSecret (encrypted), ... }
  config Json

  // Status
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?

  // Relations
  hedgeVaults HedgeVault[] // Hedge vaults using this wallet as operator

  // Indexes
  @@index([walletType])
  @@index([walletPurpose])
  @@index([userId])
  @@index([isActive])
  @@index([userId, walletHash]) // Fast user-specific lookups by hash
  @@map("automation_wallets")
}

// =============================================================================
// Shared Contract Infrastructure
// =============================================================================

// SharedContract - Platform-independent contract deployment registry
// Stores deployed shared contracts (e.g., UniswapV3PositionCloser) per chain/version
// Uses JSON config field for platform-specific data (EVM: chainId + address)
model SharedContract {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Type discriminator for platform independence (e.g., "evm-smart-contract")
  sharedContractType String

  // Contract identifier (e.g., "UniswapV3PositionCloser")
  sharedContractName String

  // Interface versioning (separate fields for querying)
  interfaceVersionMajor Int // e.g., 1
  interfaceVersionMinor Int // e.g., 0

  // Semantic hash for URL-friendly lookups
  // Format: "{type-prefix}/{name-kebab}/{major}/{minor}"
  // Example: "evm/uniswap-v3-position-closer/1/0"
  sharedContractHash String @unique

  // Platform-specific config (JSON)
  // EVM: { chainId: number, address: string }
  config Json

  // Status (allows soft-disable without deletion)
  isActive Boolean @default(true)

  // Relations
  closeOrders AutomationCloseOrder[]

  // Indexes for efficient lookups
  // Note: sharedContractHash provides uniqueness (includes type, name, version, and is derived from config)
  @@index([sharedContractType])
  @@index([sharedContractName])
  @@index([sharedContractType, sharedContractName])
  @@index([interfaceVersionMajor, interfaceVersionMinor])
  @@index([isActive])
  @@map("shared_contracts")
}

// =============================================================================
// Position Automation Models
// =============================================================================

// AutomationCloseOrder - Registered close triggers for positions
// Uses shared contracts deployed per-chain, with per-order operator specification
model AutomationCloseOrder {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Type discriminator - determines which protocol this order is for
  closeOrderType String // 'uniswapv3' (future: 'orca', 'raydium')

  // Required position link (automation is always for a specific position)
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Semantic identifier for URL-based lookups
  // Format: "sl@{tick}" or "tp@{tick}" (e.g., "sl@-12345", "tp@201120")
  // Derived from triggerMode + sqrtPriceX96Lower/Upper
  closeOrderHash String?

  // Lifecycle status
  // pending -> registering -> active -> triggering -> executed/cancelled/expired/failed
  status String @default("pending")

  // Contract config (JSON) - Immutable at registration time
  // Stores the shared contract address used for this order (snapshot at registration)
  // UniswapV3: { chainId, contractAddress, positionManager }
  automationContractConfig Json

  // SharedContract FK (nullable for existing records)
  // Links to the SharedContract used for this order; SetNull on delete keeps order functional
  sharedContractId String?
  sharedContract   SharedContract? @relation(fields: [sharedContractId], references: [id], onDelete: SetNull)

  // Protocol-specific config (JSON) - Immutable after registration
  // UniswapV3: { closeId, nftId, poolAddress, operatorAddress, triggerMode,
  //              sqrtPriceX96Lower, sqrtPriceX96Upper, payoutAddress, validUntil, slippageBps }
  config Json

  // Protocol-specific state (JSON) - Mutable
  // UniswapV3: { registrationTxHash, registeredAt, triggeredAt, triggerSqrtPriceX96,
  //              executionTxHash, executedAt, executionFeeBps, executionError, retryCount,
  //              amount0Out, amount1Out }
  state Json

  // Relations
  logs AutomationLog[] // Log entries for this close order

  // Unique constraint: one close order per position+hash (prevents duplicate triggers at same tick)
  @@unique([positionId, closeOrderHash])

  // Indexes
  @@index([closeOrderType])
  @@index([status])
  @@index([positionId])
  @@index([sharedContractId])
  @@index([closeOrderType, status]) // Fast lookup for active orders by type
  @@map("automation_close_orders")
}

// PoolPriceSubscription - Pools being monitored for price changes
// Used by the automation service to track which pools need WebSocket subscriptions
model PoolPriceSubscription {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Direct link to Pool entity (1:1 relation)
  poolId String @unique
  pool   Pool   @relation(fields: [poolId], references: [id], onDelete: Cascade)

  // Subscription state
  isActive         Boolean @default(true)
  activeOrderCount Int     @default(0) // Number of active orders watching this pool

  // Last known price state (JSON) - Mutable
  // { lastSqrtPriceX96: string, lastTick: number, lastUpdatedAt: string }
  state Json

  // Indexes
  @@index([isActive])
  @@index([activeOrderCount]) // Find pools with active orders
  @@map("pool_price_subscriptions")
}

// PoolPriceSubscribers - Tracks WebSocket subscriptions for pool price monitoring
// Used by midcurve-pool-prices service to manage real-time price feeds
// Relationship: 1 Pool -> N Subscribers (one pool can have multiple subscribers)
model PoolPriceSubscribers {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Subscription identification
  subscriptionTag String // Unique tag for WebSocket subscription management

  // Pool reference (N:1 relation with cascading delete)
  poolId String
  pool   Pool   @relation("PoolPriceSubscribers", fields: [poolId], references: [id], onDelete: Cascade)

  // Subscription state
  isActive    Boolean   @default(true)
  lastAliveAt DateTime? // Last heartbeat from subscriber (updated by consumer every 15s)

  // RabbitMQ queue tracking (set by PoolPriceSubscriber.start())
  queueName String? // Queue name in RabbitMQ - used for cleanup during pruning

  // Indexes
  @@index([poolId])
  @@index([isActive])
  @@index([subscriptionTag])
  @@index([queueName])
  @@map("pool_price_subscribers")
}

// AutomationLog - User-facing automation event logs
// Scoped to positions, tracks lifecycle events for close orders
model AutomationLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Parent: Position (logs scoped to position)
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Optional: Link to specific close order
  closeOrderId String?
  closeOrder   AutomationCloseOrder? @relation(fields: [closeOrderId], references: [id], onDelete: SetNull)

  // Log classification
  level   Int // 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR
  logType String // ORDER_CREATED, ORDER_TRIGGERED, ORDER_EXECUTING, ORDER_EXECUTED, ORDER_FAILED, ORDER_CANCELLED, RETRY_SCHEDULED

  // User-facing message
  message String

  // Platform-independent context (JSON)
  // Contains all event details in a flexible, extensible structure
  // EVM: { platform: 'evm', chainId, txHash, gasLimit, gasPrice, gasUsed, ... }
  // Solana (future): { platform: 'solana', signature, slot, ... }
  // Common: { triggerPrice, currentPrice, amounts, error, retryCount, ... }
  context Json?

  // Optional: Link to specific hedge vault
  hedgeVaultId String?
  hedgeVault   HedgeVault? @relation(fields: [hedgeVaultId], references: [id], onDelete: SetNull)

  // Indexes for efficient queries
  @@index([positionId, createdAt])
  @@index([positionId, level, createdAt])
  @@index([closeOrderId])
  @@index([hedgeVaultId])
  @@map("automation_logs")
}

// =============================================================================
// Hedge Vault Models
// =============================================================================

// HedgeVault - ERC-4626 vault managing a Uniswap V3 LP position with SIL/TIP triggers
model HedgeVault {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Contract identity
  vaultAddress String @unique
  chainId      Int

  // Position link (optional - vault can exist before position is tracked)
  positionId String?
  position   Position? @relation(fields: [positionId], references: [id], onDelete: SetNull)

  // Pool info (derived from position at init)
  poolAddress   String
  token0IsQuote Boolean

  // Trigger thresholds (immutable after deployment)
  silSqrtPriceX96      String // bigint as string
  tipSqrtPriceX96      String // bigint as string
  lossCapBps           Int
  reopenCooldownBlocks String // bigint as string

  // Vault state (synced from chain)
  // UNINITIALIZED, IN_POSITION, OUT_OF_POSITION_QUOTE, OUT_OF_POSITION_BASE, DEAD
  state          String  @default("UNINITIALIZED")
  currentTokenId String? // Current NFT token ID (bigint as string)
  lastCloseBlock String? // Block when position was last closed (bigint as string)
  costBasis      String? // Total cost basis in quote tokens (bigint as string)

  // Monitoring status
  // pending: registered but not yet active
  // active: being monitored for triggers
  // paused: temporarily stopped
  // stopped: permanently stopped
  monitoringStatus String @default("pending")

  // Operator wallet (for executing triggers)
  operatorId String?
  operator   AutomationWallet? @relation(fields: [operatorId], references: [id], onDelete: SetNull)

  // Relations
  executions HedgeVaultExecution[]
  logs       AutomationLog[]

  // Indexes
  @@index([chainId, poolAddress])
  @@index([state])
  @@index([monitoringStatus])
  @@index([operatorId])
  @@map("hedge_vaults")
}

// HedgeVaultExecution - Individual execution attempts for hedge vault triggers
model HedgeVaultExecution {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  vaultId String
  vault   HedgeVault @relation(fields: [vaultId], references: [id], onDelete: Cascade)

  // Execution details
  triggerType           String // sil, tip, reopen
  triggerSqrtPriceX96   String // Price that triggered the execution (bigint as string)
  executionSqrtPriceX96 String? // Price at execution time (bigint as string)

  // Transaction details
  txHash     String?
  status     String  @default("pending") // pending, executing, completed, failed
  error      String?
  retryCount Int     @default(0)

  // Result amounts (bigint as string)
  quoteAmount String?
  baseAmount  String?

  // Timing
  completedAt DateTime?

  // Indexes
  @@index([vaultId])
  @@index([status])
  @@index([createdAt])
  @@map("hedge_vault_executions")
}

// =============================================================================
// Domain Events Models
// =============================================================================

// DomainEventOutbox - Transactional outbox for reliable event publishing
// Events are written to this table in the same transaction as state changes,
// then published to RabbitMQ by a background worker for at-least-once delivery.
model DomainEventOutbox {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Event classification
  eventType  String // 'position.closed', 'order.cancelled', etc.
  entityType String // 'position', 'order', 'pool'
  entityId   String // ID of the entity this event is about

  // Event data
  payload  Json // Event-specific payload
  metadata Json // Source, traceId, causedBy, etc.

  // Publishing state
  status      String    @default("pending") // 'pending', 'published', 'failed'
  publishedAt DateTime?
  retryCount  Int       @default(0)
  lastError   String?

  // Indexes for efficient polling and cleanup
  @@index([status, createdAt]) // Poll for pending events
  @@index([entityType, entityId]) // Query events by entity
  @@map("domain_event_outbox")
}

// DomainEvent - Permanent event store for audit trail and analytics
// Events are copied here after successful RabbitMQ publishing.
// Provides complete history of all domain events for debugging, analytics, and compliance.
model DomainEvent {
  id        String   @id // Same ID as outbox event (CUID)
  createdAt DateTime @default(now())

  // Event classification
  eventType  String // 'position.closed', 'order.cancelled', etc.
  entityType String // 'position', 'order', 'pool'
  entityId   String // ID of the entity this event is about
  userId     String? // User ID if applicable (for user-scoped events)

  // Event data
  payload  Json // Event-specific payload
  metadata Json // Source, traceId, causedBy, etc.
  version  Int  @default(1) // Schema version for evolution

  // Indexes for efficient querying
  @@index([entityType, entityId]) // Query events by entity
  @@index([eventType, createdAt]) // Query events by type over time
  @@index([userId, createdAt]) // Query events by user over time
  @@map("domain_events")
}

// =============================================================================
// User Notification Models
// =============================================================================

// NotificationEventType - All supported notification event types
enum NotificationEventType {
  POSITION_OUT_OF_RANGE
  POSITION_IN_RANGE
  STOP_LOSS_EXECUTED
  STOP_LOSS_FAILED
  TAKE_PROFIT_EXECUTED
  TAKE_PROFIT_FAILED
}

// UserNotification - Stores notification records for users
model UserNotification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Event classification
  eventType NotificationEventType

  // Position reference (optional - some notifications may be general)
  positionId String?
  position   Position? @relation(fields: [positionId], references: [id], onDelete: SetNull)

  // Content
  title   String // Short headline (e.g., "Position Out of Range")
  message String // Detailed message

  // Read status
  isRead Boolean   @default(false)
  readAt DateTime?

  // Event-specific payload (JSON)
  // Contains: prices, amounts, txHash, error details, etc.
  payload Json

  // Indexes
  @@index([userId, createdAt])
  @@index([userId, isRead, createdAt])
  @@index([positionId])
  @@index([eventType])
  @@map("user_notifications")
}

// UserWebhookConfig - User's webhook delivery preferences
model UserWebhookConfig {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User association (1:1 relationship)
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Webhook endpoint
  webhookUrl String? // null = webhooks disabled

  // Active status
  isActive Boolean @default(false)

  // Topic filtering (which events to send)
  // JSON array of NotificationEventType values
  enabledEvents Json // ["POSITION_OUT_OF_RANGE", "STOP_LOSS_EXECUTED", ...]

  // Secret for header authentication (sent as X-Webhook-Secret header)
  webhookSecret String?

  // Last delivery status
  lastDeliveryAt     DateTime?
  lastDeliveryStatus String? // 'success' | 'failed'
  lastDeliveryError  String?

  @@map("user_webhook_configs")
}

// PositionRangeStatus - Tracks current in-range/out-of-range status per position
// Used to detect status changes and emit notification events
model PositionRangeStatus {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference (1:1 relationship)
  positionId String   @unique
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Current range status
  isInRange Boolean

  // Last price data when status was recorded
  lastSqrtPriceX96 String // bigint as string
  lastTick         Int
  lastCheckedAt    DateTime

  @@index([isInRange])
  @@map("position_range_statuses")
}

// =============================================================================
// Pool Price History Models
// =============================================================================

// PoolPricesUniswapV3 - Historical pool prices from Swap events
// Prices are sourced by subscribing to Swap events the pool contract emits
// Events with removed=true (chain reorgs) should delete corresponding entries
model PoolPricesUniswapV3 {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Chain identification
  chainId Int

  // Transaction identification (for uniqueness and ordering)
  blockHash        String
  transactionHash  String
  transactionIndex Int
  logIndex         Int    // Position of log within the block (not transaction)
  blockNumber      Int
  blockTimestamp   DateTime

  // Pool reference (cascade delete when pool is deleted)
  poolId String
  pool   Pool   @relation("PoolPricesUniswapV3", fields: [poolId], references: [id], onDelete: Cascade)

  // Price data (stored as string for bigint precision)
  sqrtPriceX96         String // bigint as string
  token1PricePerToken0 String // bigint as string
  token0PricePerToken1 String // bigint as string

  // Finality flag (false until confirmed)
  isFinal Boolean @default(false)

  // Unique constraint for deduplication
  @@unique([chainId, blockHash, transactionHash, logIndex])

  // Indexes for efficient querying
  // Ordering (latest first): blockNumber DESC, logIndex DESC
  // Ordering (earliest first): blockNumber ASC, logIndex ASC
  @@index([poolId, blockNumber(sort: Desc), logIndex(sort: Desc)], map: "pool_prices_uniswapv3_latest_first_idx")
  @@index([poolId, blockNumber(sort: Asc), logIndex(sort: Asc)], map: "pool_prices_uniswapv3_earliest_first_idx")
  @@index([chainId])
  @@index([isFinal])
  @@map("pool_prices_uniswapv3")
}
