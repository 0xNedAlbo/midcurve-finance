// Prisma schema file for Midcurve Finance
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Models for concentrated liquidity positions
// Supporting: Uniswap V3 (Ethereum), Orca (Solana), Raydium (Solana), PancakeSwap (BSC)

// =============================================================================
// Authentication Models
// =============================================================================

// Session - Custom server-side session storage (replaces Auth.js JWT)
// Session ID stored in httpOnly cookie, session data stored in PostgreSQL
model Session {
  id        String @id @default(cuid())
  sessionId String @unique // 64-char random token stored in httpOnly cookie
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session metadata
  createdAt  DateTime @default(now())
  expiresAt  DateTime // Session expiry time (default 30 days)
  lastUsedAt DateTime @default(now())

  // Security context
  userAgent String? // Browser user agent for session tracking
  ipAddress String? // IP address for session tracking

  @@index([sessionId])
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

// AuthWalletAddress - User wallet addresses (chain-agnostic, same key = same user across all EVM chains)
model AuthWalletAddress {
  id        String   @id @default(cuid())
  userId    String
  address   String // Normalized (EIP-55 checksum)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints â€” address alone is unique (same key controls all EVM chains)
  @@unique([address])
  @@index([userId])
  @@map("auth_wallet_addresses")
}

// =============================================================================
// Cache & Core Models
// =============================================================================

model Cache {
  key       String   @id
  value     Json
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for efficient queries
  @@index([expiresAt])
  @@map("cache")
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User identification
  name  String?
  email String? @unique
  image String?

  // Session relation (custom server-side sessions)
  sessions Session[]

  // Wallet addresses
  walletAddresses AuthWalletAddress[]

  // Midcurve position relations
  positions             Position[]
  quoteTokenPreferences UserQuoteTokenPreference[]

  // Notification relations
  notifications UserNotification[]
  webhookConfig UserWebhookConfig?

  // Favorite pools
  favoritePools FavoritePool[]

  // Indexes for efficient queries
  @@index([name])
  @@index([email])
  @@map("users")
}

model Token {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  tokenType String // 'evm-erc20' or 'solana-spl'
  name      String
  symbol    String
  decimals  Int

  // Common optional fields
  logoUrl     String?
  coingeckoId String?
  marketCap   Float? // USD market cap from CoinGecko

  // Platform-specific configuration (JSON)
  // Contains address/mint, chainId/programId, platform identifier, etc.
  config Json

  // Relations
  poolsAsToken0 Pool[] @relation("PoolToken0")
  poolsAsToken1 Pool[] @relation("PoolToken1")

  // Indexes for efficient queries
  @@index([tokenType])
  @@index([symbol])
  @@index([coingeckoId])
  @@map("tokens")
}

// CoingeckoToken - Lookup table mapping ERC-20 addresses to CoinGecko IDs
// Used for token enrichment and price discovery (NOT part of Token entity)
// One record per token+chain combination
model CoingeckoToken {
  id        String   @id // Format: "erc20:{chainId}:{normalizedAddress}"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // CoinGecko identifier (e.g., 'usd-coin', 'ethereum', 'wrapped-bitcoin')
  coingeckoId String

  // Token metadata for text-based searches
  name   String // Token name (e.g., 'USD Coin', 'Ethereum')
  symbol String // Token symbol (e.g., 'USDC', 'ETH')

  // Enrichment data from /coins/markets endpoint
  enrichedAt   DateTime? // When token was last enriched with market data
  imageUrl     String? // Token logo URL from CoinGecko
  marketCapUsd Float? // Market cap in USD

  // Platform-specific configuration (JSON)
  // Contains: { chainId: number, tokenAddress: string }
  config Json

  // Indexes for efficient lookups
  @@index([coingeckoId])
  @@index([symbol])
  @@index([name])
  @@index([enrichedAt]) // For finding unenriched/stale tokens
  @@map("coingecko_tokens")
}

model Pool {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Common required fields
  protocol String // 'uniswapv3', etc.
  poolType String // 'CL_TICKS'
  token0Id String
  token1Id String
  feeBps   Int // Fee in basis points (3000 = 0.3%)

  // Pool hash for fast lookups and uniqueness
  // Human-readable composite key, format: "{protocol}/{chainId}/{poolAddress}"
  // Example: "uniswapv3/1/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8"
  poolHash String? @unique

  // Protocol-specific configuration (JSON) - Immutable
  // Contains pool address, tick spacing, chainId, token addresses, etc.
  config Json

  // Protocol-specific state (JSON) - Mutable
  // Contains current price, liquidity, tick, fee growth, etc.
  // For Uniswap V3: sqrtPriceX96, currentTick, liquidity, feeGrowthGlobal0/1
  state Json

  // Relations to Token model
  // Note: In TypeScript, Pool.token0 and Pool.token1 are full Token objects
  // In database, we use foreign keys for efficient storage and queries
  token0            Token                  @relation("PoolToken0", fields: [token0Id], references: [id])
  token1            Token                  @relation("PoolToken1", fields: [token1Id], references: [id])
  positions         Position[]
  poolPrices        PoolPrice[]
  favoritedBy       FavoritePool[] // Users who favorited this pool

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolType])
  @@index([token0Id])
  @@index([token1Id])
  @@index([poolHash])
  @@map("pools")
}

model Position {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol     String // 'uniswapv3', etc.
  positionType String // 'CL_TICKS'

  // Data ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Position hash for fast lookups
  // Human-readable composite key: protocol/chainId/nftId (for UniswapV3)
  // Format is protocol-specific, generated by createHash() method
  // Nullable initially for migration, will become required after backfill
  // NOTE: Uniqueness is enforced per-user via @@unique([userId, positionHash])
  // This allows multiple users to import/watch the same on-chain position
  positionHash String?

  // PnL related fields (stored as string for bigint precision)
  currentValue     String // bigint as string
  currentCostBasis String // bigint as string
  realizedPnl      String // bigint as string
  unrealizedPnl    String // bigint as string

  // General cash flow fields for non-AMM protocols (stored as string for bigint precision)
  // For UniswapV3: always "0" (unused - fees tracked in collectedFees/unClaimedFees)
  // For Hyperliquid: funding payments, interest, etc.
  // Total Realized PnL = realizedPnl + realizedCashflow
  // Total Unrealized PnL = unrealizedPnl + unrealizedCashflow
  realizedCashflow   String @default("0") // bigint as string - locked-in cash flow
  unrealizedCashflow String @default("0") // bigint as string - pending cash flow

  // Cash flow related fields for AMM protocols (stored as string for bigint precision)
  collectedFees       String // bigint as string
  unClaimedFees       String // bigint as string
  lastFeesCollectedAt DateTime? // null = no fees collected yet

  // APR metrics
  totalApr Float? // Total APR (time-weighted across all periods + unrealized), null if below threshold

  // Price range (stored as string for bigint precision)
  priceRangeLower String // bigint as string
  priceRangeUpper String // bigint as string

  // Pool and token roles
  poolId        String
  pool          Pool    @relation(fields: [poolId], references: [id])
  isToken0Quote Boolean // true: token0 is quote, token1 is base; false: token0 is base, token1 is quote

  // Position state
  positionOpenedAt DateTime
  positionClosedAt DateTime?
  isActive         Boolean

  // Protocol-specific data (JSON)
  config Json // Immutable: chainId, nftId, poolAddress, ticks, etc.
  state  Json // Mutable: ownerAddress, liquidity, feeGrowth, tokensOwed, etc.

  // Relations
  ledgerEvents     PositionLedgerEvent[]
  aprPeriods       PositionAprPeriod[]
  syncState        PositionSyncState? // 1:1 relation, optional for backward compatibility
  closeOrders          CloseOrder[] // Close order cache (SL/TP)
  automationLogs       AutomationLog[] // Automation event logs for this position
  notifications    UserNotification[] // Notifications related to this position
  rangeStatus      PositionRangeStatus? // 1:1 range tracking for notifications

  @@unique([userId, positionHash]) // Same user can't import same position twice; allows multi-user watching
  // Indexes for efficient queries
  @@index([protocol])
  @@index([positionType])
  @@index([userId])
  @@index([poolId])
  @@index([isActive])
  @@map("positions")
}

model PositionSyncState {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference (1:1 relationship)
  positionId String   @unique
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Sync tracking
  lastSyncAt DateTime? // null = never synced yet
  lastSyncBy String? // 'user-refresh', future: 'auto-refresh', 'webhook', etc.

  // Protocol-specific sync state (JSON)
  // For UniswapV3: { lastEventBlock: number, lastFinalizedBlock: number, lastEventId: string?, ... }
  // For other protocols: protocol-specific sync metadata
  state Json

  // Indexes for efficient queries
  @@index([positionId])
  @@index([lastSyncAt])
  @@index([lastSyncBy])
  @@map("position_sync_states")
}

model PoolPrice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol identification
  protocol String // 'uniswapv3', etc.

  // Pool reference
  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id], onDelete: Cascade)

  // Timestamp when price was recorded
  timestamp DateTime

  // Price fields (stored as string for bigint precision)
  // Price in smallest token units
  token1PricePerToken0 String // bigint as string - How much token1 for 1 token0
  token0PricePerToken1 String // bigint as string - How much token0 for 1 token1

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (e.g., blockNumber, blockTimestamp for Uniswap V3)
  state  Json // Protocol-specific state (e.g., sqrtPriceX96, tick for Uniswap V3)

  // Indexes for efficient queries
  @@index([protocol])
  @@index([poolId])
  @@index([timestamp])
  @@index([poolId, timestamp]) // Compound index for time-range queries on specific pool
  @@map("pool_prices")
}

model PositionLedgerEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Protocol and event chaining
  protocol      String // 'uniswapv3', etc.
  previousId    String? // null for first event
  previousEvent PositionLedgerEvent?  @relation("EventChain", fields: [previousId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  nextEvents    PositionLedgerEvent[] @relation("EventChain")

  // Event identification
  timestamp DateTime // Block timestamp (from blockchain)
  eventType String // 'INCREASE_POSITION', 'DECREASE_POSITION', 'COLLECT'
  // inputHash: MD5(blockNumber + txIndex + logIndex) for deduplication within a position
  // NOTE: Uniqueness is enforced per-position via @@unique([positionId, inputHash])
  // This allows multiple users to import the same on-chain position with the same events
  inputHash String

  // Financial data (stored as string for bigint precision)
  poolPrice    String // bigint as string - Quote tokens per 1 Base token (in smallest units)
  token0Amount String // bigint as string - Token0 amount in smallest units
  token1Amount String // bigint as string - Token1 amount in smallest units
  tokenValue   String // bigint as string - Total value in quote token units
  rewards      Json // Array of {tokenId: string, tokenAmount: string, tokenValue: string}

  // PnL tracking (stored as string for bigint precision)
  deltaCostBasis      String // bigint as string - Change in cost basis from this event
  costBasisAfter      String // bigint as string - Cumulative cost basis after this event
  deltaPnl            String // bigint as string - Change in realized PnL from this event
  pnlAfter            String // bigint as string - Cumulative realized PnL after this event
  deltaCollectedFees      String @default("0") // bigint as string - Fees collected in this event
  collectedFeesAfter      String @default("0") // bigint as string - Cumulative collected fees after this event
  deltaRealizedCashflow   String @default("0") // bigint as string - Realized cashflow in this event (perpetuals, etc.)
  realizedCashflowAfter   String @default("0") // bigint as string - Cumulative realized cashflow after this event

  // Protocol-specific data (JSON)
  config Json // Protocol-specific config (blockNumber, txIndex, logIndex, liquidity, fees, etc.)
  state  Json // Raw event data (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, COLLECT)

  @@unique([positionId, inputHash]) // Deduplication per-position; allows multi-user event import
  // Indexes for efficient queries
  @@index([positionId, timestamp]) // Time-series queries for position
  @@index([protocol]) // Filter by protocol
  @@index([eventType]) // Filter by event type
  @@index([previousId]) // Event chain traversal
  @@map("position_ledger_events")
}

model PositionAprPeriod {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Period boundaries (events that define this period)
  startEventId String // Event that started this period (INCREASE_POSITION or COLLECT)
  endEventId   String // Event that ended this period (next COLLECT or last event)

  // Time range
  startTimestamp  DateTime // When period started
  endTimestamp    DateTime // When period ended (or last event time)
  durationSeconds Int // endTimestamp - startTimestamp (in seconds)

  // Financial metrics (stored as string for bigint precision)
  costBasis         String // Average cost basis during period (in quote token units)
  collectedFeeValue String // Total fees collected during period (in quote token units)

  // APR calculation
  aprBps Int // Annual Percentage Rate in basis points (e.g., 2500 = 25.00%)

  // For debugging/auditing
  eventCount Int // Number of events included in period calculation

  // Indexes for efficient queries
  @@index([positionId, startTimestamp]) // Time-range queries for position
  @@index([positionId, endTimestamp]) // Time-range queries for position
  @@index([aprBps]) // Sort/filter by APR performance
  @@map("position_apr_periods")
}

model UserQuoteTokenPreference {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User reference
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Protocol (NO chainId - preferences are protocol-wide)
  // User can have one preference set per protocol
  protocol String // 'uniswapv3', 'orca', 'raydium', etc.

  // Ordered list of preferred quote token identifiers (protocol-specific)
  // - EVM protocols: normalized addresses ["0xA0b8...", "0xC02a..."]
  // - Solana protocols: mint addresses ["EPjFWdd...", "So11111..."]
  // First match wins when both tokens in pair are in this list
  preferredQuoteTokens Json

  // Composite unique constraint and indexes
  @@unique([userId, protocol])
  @@index([userId])
  @@index([protocol])
  @@map("user_quote_token_preferences")
}

// =============================================================================
// Automation Wallet Models (for midcurve-signer)
// =============================================================================

// AutomationWallet - Managed wallets for automated DeFi operations
// Supports multiple platforms: EVM, Solana, Hyperliquid, etc.
model AutomationWallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Wallet type discriminator
  walletType String // 'evm', 'solana', 'hyperliquid'

  // Wallet purpose discriminator
  walletPurpose String @default("automation") // 'automation'

  // Owner reference (for authorization, NOT unique - one user can have many wallets)
  userId String

  // User-friendly label
  label String // "Automation Wallet", "Hyperliquid Trading Wallet", etc.

  // Wallet hash for fast lookups and uniqueness
  // Human-readable composite key, format is platform-specific:
  // - EVM: "evm/{walletAddress}" (the actual signing wallet address)
  // - Solana: "solana/{programId}/{walletPubkey}"
  // - Hyperliquid: "hyperliquid/{userId}/{vaultAddress}"
  // Generated by createWalletHash() method in each platform service
  walletHash String @unique

  // Platform-specific configuration (JSON)
  // EVM: { walletAddress, kmsKeyId, keyProvider }
  // Solana: { programId, walletPubkey, ... }
  // Hyperliquid: { apiKey, apiSecret (encrypted), ... }
  config Json

  // Status
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?

  // Indexes
  @@index([walletType])
  @@index([walletPurpose])
  @@index([userId])
  @@index([isActive])
  @@index([userId, walletHash]) // Fast user-specific lookups by hash
  @@map("automation_wallets")
}

// =============================================================================
// Shared Contract Infrastructure
// =============================================================================

// SharedContract - Platform-independent contract deployment registry
// Stores deployed shared contracts (e.g., UniswapV3PositionCloser) per chain/version
// Uses JSON config field for platform-specific data (EVM: chainId + address)
model SharedContract {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Type discriminator for platform independence (e.g., "evm-smart-contract")
  sharedContractType String

  // Contract identifier (e.g., "UniswapV3PositionCloser")
  sharedContractName String

  // Interface versioning (separate fields for querying)
  interfaceVersionMajor Int // e.g., 1
  interfaceVersionMinor Int // e.g., 0

  // Semantic hash for URL-friendly lookups
  // Format: "{type-prefix}/{name-kebab}/{major}/{minor}"
  // Example: "evm/uniswap-v3-position-closer/1/0"
  sharedContractHash String @unique

  // Platform-specific config (JSON)
  // EVM: { chainId: number, address: string }
  config Json

  // Status (allows soft-disable without deletion)
  isActive Boolean @default(true)

  // Relations
  closeOrders CloseOrder[]

  // Indexes for efficient lookups
  // Note: sharedContractHash provides uniqueness (includes type, name, version, and is derived from config)
  @@index([sharedContractType])
  @@index([sharedContractName])
  @@index([sharedContractType, sharedContractName])
  @@index([interfaceVersionMajor, interfaceVersionMinor])
  @@index([isActive])
  @@map("shared_contracts")
}

// =============================================================================
// Position Automation Models
// =============================================================================

// CloseOrder - Platform-independent close order model
// Follows the Position model pattern: protocol discriminator + JSON config/state.
// Generic columns for universal lifecycle; protocol-specific data in config/state JSON.
model CloseOrder {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Protocol discrimination (matches Position.protocol)
  protocol String // 'uniswapv3', future: 'aave', etc.

  // Position link
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Contract reference
  sharedContractId String?
  sharedContract   SharedContract? @relation(fields: [sharedContractId], references: [id], onDelete: SetNull)

  // === AUTOMATION LIFECYCLE ===
  // Single field tracking our system's engagement with the order.
  // monitoring: price monitor watching for trigger condition
  // executing:  execution in progress (simulation/signing/broadcasting)
  // retrying:   execution failed, waiting 60s before retry
  // failed:     max execution attempts exhausted (terminal)
  // executed:   order executed successfully on-chain (terminal)
  automationState   String @default("monitoring") // monitoring|executing|retrying|failed|executed
  executionAttempts Int    @default(0) // resets to 0 when price moves away from trigger
  lastError         String? // last execution error for diagnostics

  // === IDENTITY HASH (replaces protocol-specific unique constraints) ===
  // Format: "{protocol}/{identity-components}"
  // UniswapV3: "uniswapv3/{chainId}/{nftId}/{triggerMode}"
  orderIdentityHash String @unique

  // URL-friendly lookup hash (protocol-specific format)
  // UniswapV3: "sl@{tick}" or "tp@{tick}"
  closeOrderHash String?

  // === SYNC METADATA ===
  lastSyncedAt DateTime? // When last refreshed from chain/source

  // === PROTOCOL-SPECIFIC DATA ===
  // config: Immutable identity + registration data
  //   UniswapV3: { chainId, nftId, triggerMode, contractAddress }
  config Json

  // state: Mutable on-chain + off-chain state (refreshable)
  //   UniswapV3: { triggerTick, slippageBps, payoutAddress, operatorAddress,
  //                owner, pool, validUntil, swapDirection, swapSlippageBps,
  //                registrationTxHash, registeredAt, lastSyncBlock }
  state Json

  // Relations
  logs AutomationLog[]

  // Constraints
  @@unique([positionId, closeOrderHash])

  // Indexes
  @@index([protocol])
  @@index([automationState])
  @@index([positionId])
  @@index([closeOrderHash])
  @@index([sharedContractId])
  @@map("close_orders")
}

// OnchainDataSubscribers - Generic table for onchain event subscriptions
// Discriminator pattern: 'erc20-approval', future: 'erc20-transfer', etc.
// Used by midcurve-onchain-data to manage WebSocket subscriptions for various event types
model OnchainDataSubscribers {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Discriminator - determines subscription type and config/state schema
  subscriptionType String // 'erc20-approval', future: 'erc20-transfer', etc.

  // Client-facing ID for polling (short, URL-safe)
  subscriptionId String @unique

  // Lifecycle state
  // active: currently subscribed to WebSocket
  // paused: removed from WebSocket (subscriber stopped polling)
  // deleted: marked for cleanup (will be removed by pruning job)
  status String @default("active") // 'active', 'paused', 'deleted'

  // Lifecycle expiry (ms without polling before pause)
  // null = persistent (never expires, e.g. automation subscriptions)
  // number = ms threshold (e.g. 60000 for UI subscriptions)
  expiresAfterMs Int?

  // Heartbeat tracking
  lastPolledAt DateTime? // Updated when client polls GET endpoint
  pausedAt     DateTime? // When subscription was paused

  // Platform-specific config (JSON) - Immutable after creation
  // For erc20-approval: { chainId, tokenAddress, walletAddress, spenderAddress, startedAt }
  config Json

  // Platform-specific state (JSON) - Mutable
  // For erc20-approval: { approvalAmount, lastEventBlock, lastEventTxHash, lastUpdatedAt }
  state Json

  // Indexes for efficient queries
  @@index([subscriptionType])
  @@index([status])
  @@index([subscriptionType, status])
  @@index([lastPolledAt])
  @@index([pausedAt])
  @@map("onchain_data_subscribers")
}

// AutomationLog - User-facing automation event logs
// Scoped to positions, tracks lifecycle events for close orders
model AutomationLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Parent: Position (logs scoped to position)
  positionId String
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Optional: Link to specific close order
  closeOrderId String?
  closeOrder   CloseOrder? @relation(fields: [closeOrderId], references: [id], onDelete: SetNull)

  // Log classification
  level   Int // 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR
  logType String // ORDER_CREATED, ORDER_TRIGGERED, ORDER_EXECUTING, ORDER_EXECUTED, ORDER_FAILED, ORDER_CANCELLED, RETRY_SCHEDULED

  // User-facing message
  message String

  // Platform-independent context (JSON)
  // Contains all event details in a flexible, extensible structure
  // EVM: { platform: 'evm', chainId, txHash, gasLimit, gasPrice, gasUsed, ... }
  // Solana (future): { platform: 'solana', signature, slot, ... }
  // Common: { triggerPrice, currentPrice, amounts, error, retryCount, ... }
  context Json?

  // Indexes for efficient queries
  @@index([positionId, createdAt])
  @@index([positionId, level, createdAt])
  @@index([closeOrderId])
  @@map("automation_logs")
}

// =============================================================================
// Domain Events Models
// =============================================================================

// DomainEventOutbox - Transactional outbox for reliable event publishing
// Events are written to this table in the same transaction as state changes,
// then published to RabbitMQ by a background worker for at-least-once delivery.
model DomainEventOutbox {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Event classification
  eventType  String // 'position.closed', 'order.cancelled', etc.
  entityType String // 'position', 'order', 'pool'
  entityId   String // ID of the entity this event is about

  // Event data
  payload  Json // Event-specific payload
  metadata Json // Source, traceId, causedBy, etc.

  // Publishing state
  status      String    @default("pending") // 'pending', 'published', 'failed'
  publishedAt DateTime?
  retryCount  Int       @default(0)
  lastError   String?

  // Indexes for efficient polling and cleanup
  @@index([status, createdAt]) // Poll for pending events
  @@index([entityType, entityId]) // Query events by entity
  @@map("domain_event_outbox")
}

// DomainEvent - Permanent event store for audit trail and analytics
// Events are copied here after successful RabbitMQ publishing.
// Provides complete history of all domain events for debugging, analytics, and compliance.
model DomainEvent {
  id        String   @id // Same ID as outbox event (CUID)
  createdAt DateTime @default(now())

  // Event classification
  eventType  String // 'position.closed', 'order.cancelled', etc.
  entityType String // 'position', 'order', 'pool'
  entityId   String // ID of the entity this event is about
  userId     String? // User ID if applicable (for user-scoped events)

  // Event data
  payload  Json // Event-specific payload
  metadata Json // Source, traceId, causedBy, etc.
  version  Int  @default(1) // Schema version for evolution

  // Indexes for efficient querying
  @@index([entityType, entityId]) // Query events by entity
  @@index([eventType, createdAt]) // Query events by type over time
  @@index([userId, createdAt]) // Query events by user over time
  @@map("domain_events")
}

// =============================================================================
// User Notification Models
// =============================================================================

// NotificationEventType - All supported notification event types
enum NotificationEventType {
  POSITION_OUT_OF_RANGE
  POSITION_IN_RANGE
  STOP_LOSS_EXECUTED
  STOP_LOSS_FAILED
  TAKE_PROFIT_EXECUTED
  TAKE_PROFIT_FAILED
}

// UserNotification - Stores notification records for users
model UserNotification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Event classification
  eventType NotificationEventType

  // Position reference (optional - some notifications may be general)
  positionId String?
  position   Position? @relation(fields: [positionId], references: [id], onDelete: SetNull)

  // Content
  title   String // Short headline (e.g., "Position Out of Range")
  message String // Detailed message

  // Read status
  isRead Boolean   @default(false)
  readAt DateTime?

  // Event-specific payload (JSON)
  // Contains: prices, amounts, txHash, error details, etc.
  payload Json

  // Indexes
  @@index([userId, createdAt])
  @@index([userId, isRead, createdAt])
  @@index([positionId])
  @@index([eventType])
  @@map("user_notifications")
}

// UserWebhookConfig - User's webhook delivery preferences
model UserWebhookConfig {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User association (1:1 relationship)
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Webhook endpoint
  webhookUrl String? // null = webhooks disabled

  // Active status
  isActive Boolean @default(false)

  // Topic filtering (which events to send)
  // JSON array of NotificationEventType values
  enabledEvents Json // ["POSITION_OUT_OF_RANGE", "STOP_LOSS_EXECUTED", ...]

  // Secret for header authentication (sent as X-Webhook-Secret header)
  webhookSecret String?

  // Last delivery status
  lastDeliveryAt     DateTime?
  lastDeliveryStatus String? // 'success' | 'failed'
  lastDeliveryError  String?

  @@map("user_webhook_configs")
}

// PositionRangeStatus - Tracks current in-range/out-of-range status per position
// Used to detect status changes and emit notification events
model PositionRangeStatus {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Position reference (1:1 relationship)
  positionId String   @unique
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  // Current range status
  isInRange Boolean

  // Last price data when status was recorded
  lastSqrtPriceX96 String // bigint as string
  lastTick         Int
  lastCheckedAt    DateTime

  @@index([isInRange])
  @@map("position_range_statuses")
}

// =============================================================================
// Pool Price History Models
// =============================================================================

// =============================================================================
// User Favorite Pools
// =============================================================================

// FavoritePool - User's saved/bookmarked pools for quick access
// Simple junction table linking users to pools they want to track
model FavoritePool {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User reference
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Pool reference
  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id], onDelete: Cascade)

  // Unique constraint: one favorite per user+pool combination
  @@unique([userId, poolId])

  // Indexes for efficient queries
  @@index([userId])
  @@index([poolId])
  @@index([userId, createdAt]) // For listing user's favorites in order
  @@map("favorite_pools")
}
